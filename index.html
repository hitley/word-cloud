<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
}

.node-text {
    stroke : rgb(40,40,40);
    fill: rgb(40,40,40);
    font-family: Verdana;
    /*font-size: 25px;*/
    cursor: move;
}

.linkNode-text {
    stroke : rgb(40,40,40);
    fill: rgb(40,40,40);
    font-family: Verdana;
    font-size: 30px;
    cursor: move;
}


.link {
  fill: none;
  stroke: rgb(145,145,145);
  stroke-width: 3.0px;
  marker-end: url(#end-arrow)
}

.end-arrow path {
  fill: rgb(145,145,145);
}

.background {
  fill: none;
}

.rect {
  stroke : rgb(145,145,145);
  fill: rgb(204,204,204);
  opacity: 1.0;
}


</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://marvl.infotech.monash.edu/webcola/cola.v3.min.js"></script>
<script>

var width = 2048,
    height = 1200;

var color = d3.scale.category20();

var force = cola.d3adaptor()
    .linkDistance(200)
    .size([width, height])
    .avoidOverlaps(true)
    ;


var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("pointer-events", "all")
    ;

svg.append('svg:defs').append('svg:marker')
            .attr('class', 'end-arrow')
            .attr('id', 'end-arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', calculateMarkerOrientation)
          .append('svg:path')
            .attr('d', 'M0,-5L10,0L0,5L2,0')
            .attr('stroke-width', '0px')
            .attr('fill', '#000')
            ;


svg.append('rect')
            .attr('class', 'background')
            .attr('width', "100%")
            .attr('height', "100%")
            .call(d3.behavior.zoom().on("zoom", redraw));

var vis = svg
            .append('g')
            .attr('transform', 'translate(250,250) scale(0.3)');

function redraw() {
    vis.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
}            

function calculateMarkerOrientation(d) {
  return 'auto';
}

d3.tsv("brain-dump.tsv", function(error, data) {
  var nodeMap = {};
  var nodes = createNodes(nodeMap, data);
  var links= createLinks(nodes, nodeMap, data);

  var graph = {
    nodes:nodes,
    links:links
  }

  force
      .nodes(graph.nodes)
      .links(graph.links)
      .start();

  var link = vis.selectAll(".link")
      .data(graph.links)
    .enter().append("line")
      .attr("class", 'link');

  var node = vis.selectAll(".allNodes")
      .data(graph.nodes)
    .enter()
      .append("g")
      .attr("class", function(d) {return d.type;})
      .call(force.drag);

  var rect = vis.selectAll('.node').append('rect')
                .attr('class','rect')
                // .style('fill', function(d) { return color(d.group); })
                .attr("rx", 10).attr("ry", 10)
                //.style('fill', "white")
                .attr('stroke', 'black')
                ;

  // var text = node.append('text')
  //           .attr("class", function(d) {return d.type+"-text"});

  var text = node.append('text')
            .attr("class", function(d) {return d.type+"-text"});
            


  force.on("tick", function() {

    text
        .attr("x", function(d) { return calculateBoxXPos( text, d ); })
        .attr("y", function(d) { return calculateBoxYPos( text, d ); })
        .attr("dx", function(d) { return border; })
        .attr("dy", function(d) { return calculateBoxHeigth( text, d)/2+calculateFontSize(d)/4; })
        .attr("font-size", function(d) { return calculateFontSize(d); })
        .text(function(d) { return d.name; });


    rect.attr("x", function(d) { return calculateBoxXPos( text, d ); })
        .attr("y", function(d) { return calculateBoxYPos( text, d ); })
        .attr("width",  function(d) { return calculateBoxWidth(text , d); })
        .attr("height", function(d) { return calculateBoxHeigth(text, d); });            


    link.attr("x1", function(d) { return calculateLinkSourcePoint(d).x; })
        .attr("y1", function(d) { return calculateLinkSourcePoint(d).y; })
        .attr("x2", function(d) { return calculateLinkTargetPoint(d).x; })
        .attr("y2", function(d) { return calculateLinkTargetPoint(d).y; });

// use with path
//    link.attr("d", diagonal);

    nodes.forEach( function(d) {
        d.width = calculateBoxWidth(text , d);
        d.height = calculateBoxHeigth(text, d);
      }
    );

  });
});

var border = 10;

var calculateBoxXPos = function(text, d) {
    return d.x - calculateBoxWidth(text, d)/2;
}

var calculateBoxYPos = function(text, d) {
    return d.y - calculateBoxHeigth(text, d)/2;
}

var calculateBoxWidth = function(text, d) {
    return text[0][d.index].getBBox().width+2*border;
}

var calculateBoxHeigth = function(text, d) {
    return text[0][d.index].getBBox().height+2*border;
}

var calculateLinkSourcePoint = function(d) {
      var s = d.source;
      var t = d.target;
      return calculateIntersection(s.x, s.y, s.width, s.height, t.x, t.y);
}

var calculateLinkTargetPoint = function(d) {
      var s = d.target;
      var t = d.source;
      return calculateIntersection(s.x, s.y, s.width, s.height, t.x, t.y);
}

// use this when using paths for links
var diagonal = d3.svg.diagonal()
    .source(function(d) {
      return calculateLinkSourcePoint(d);
    })            
    .target(function(d) {
      return calculateLinkTargetPoint(d);
    })
    .projection(function(d) { return [d.x, d.y]; });



var createNodes = function(nodeMap, data) {
  var nodes = [];
  var index=0
  var entry = null;

  data.forEach(function(d) {
    var statement = d.statement;
    entry = parseEntry(entry, statement);
    if( !nodeMap.hasOwnProperty(entry.source) ) {
      var node = {
        "type": "node",
        "index": index,
        "name": entry.source,
        "group": 1,
        "inboundCount": 0,
        "outboundCount": 0
      };
      nodes.push(node);
      nodeMap[entry.source] = node;
      index++;
    }
    if( !nodeMap.hasOwnProperty(entry.target) ) {
      var node = {
        "type": "node",
        "index": index,
        "name": entry.target,
        "group": 1,
        "inboundCount": 0,
        "outboundCount": 0
      };
      nodes.push(node);
      nodeMap[entry.target] = node;
      index++;
    }
  });

  return nodes;
}

var createLinks = function(nodes, nodeMap, data) {
  var links = [];
  var entry = null;
  var index = 1000;

  data.forEach(function(d) {
    var statement = d.statement;
    entry = parseEntry(entry, statement);
    var linkNode = {
        "type": "linkNode",
        "index": index,
        "name": entry.label,
        "group": 1,
        "inboundCount": 0,
        "outboundCount": 0
    };
    nodes.push(linkNode);
    index++;

    links.push({
      "source": nodeMap[entry.source].index,
      "target": linkNode,
      "value": 10,
      "label": entry.label
    });
    links.push({
      "source": linkNode,
      "target": nodeMap[entry.target].index,
      "value": 10,
      "label": entry.label
    });
    nodeMap[entry.target].inboundCount = nodeMap[entry.target].inboundCount+1
    nodeMap[entry.source].outboundCount = nodeMap[entry.source].outboundCount+1

  });

  return links;
}

var parseEntry = function(previousEntry, statement) {
  var splitresult = statement.split("->")
  var result 

  switch(splitresult.length) {
    case 2: {
      result = {
        "source" : previousEntry.source,
        "label" : splitresult[0].trim(),
        "target" : splitresult[1].trim()
      }
    break;
    }
    case 3: {
      var source = splitresult[0].trim().length != 0 ? splitresult[0].trim() : previousEntry.source;
      result = {
        "source" : source,
        "label" : splitresult[1].trim(),
        "target" : splitresult[2].trim()
      }
    break;
    }
    default :  {
      result = {
        "source" : statement,
        "label" : "",
        "target" : ""
      }
    }

  }

  return result;
}

var calculateFontSize = function(node) {
    var minSize = 30;
    var maxSize = 50

    var size = 10*(node.inboundCount+node.outboundCount);

    return size > minSize ? size < maxSize ? size : maxSize : minSize;
    //return size;
}

var calculateIntersection = function(x1, y1, w1, h1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
    var dxSign = dx >= 0 ? 1 : -1; 
    var dySign = dy >= 0 ? 1 : -1; 
    var dx2 = dx/dy * dySign * h1/2;
    var dy2 = dy/dx * dxSign * w1/2;
    var x = Math.min(Math.abs(dx2), w1/2) * dxSign + x1;
    var y = Math.min(Math.abs(dy2), h1/2) * dySign + y1;
    // console.log("x: "+x+"| y: "+y);
    return {
      "x":x,
      "y":y
    }
}

</script>